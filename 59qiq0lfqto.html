<div>What these commands do: </div><div></div><div><code>data_file = file_folder + file_name</code>tells what the name of the file is and where to find it!&nbsp; Tip: If you have trouble determining how to specify the file_folder location for your data, an easy workaround is to put the&nbsp;data in the same folder as your Python program . Then you can  type&nbsp;<code>np.loadtxt(file_name, ...)&nbsp;</code>instead of&nbsp;&nbsp;<code>np.loadtxt(data_file, ...)</code>  if you prefer. </div><div></div><div><code>delimiter = ',' </code>tells <code>loadtxt</code> that your data is in comma separated variable format (CSV). The character used to&nbsp; separate one column of data from another is called the 'delimiter.' </div><div></div><div><code>skiprows = 1</code> tells&nbsp;<code>loadtxt</code>that <i>one row</i> of text in the CSV file should be <i>skipped</i> before looking for data. In this case, the first row of text contains suggested names for each column of data (as shown in Table&nbsp;<span class="au-ref raw v1">\ref{296817}</span>).&nbsp;</div><div></div><div><code>unpack = True</code> tells&nbsp;<code>loadtxt</code> that the data is in a 'packed' data format (in which each&nbsp;<i>variable</i> corresponds to a different&nbsp;<i>column</i> instead of to a different&nbsp;<i>row</i> )and therefore needs to be 'unpacked' when loaded. This is the typical arrangement for data in spreadsheets. Use <code>unpack = False</code> if the data is in an 'unpacked' data format &nbsp; (in which each&nbsp;<i>variable</i> corresponds to a different&nbsp;<i>column</i> instead of  a different&nbsp;<i>row</i> ).&nbsp;</div><div></div><div><code>usecols = (0, 1, 2)</code> says the data you are looking for is in the first 3 columns, which are numbered 0, 1, and 2 (because Python always starts from zero when counting).&nbsp; In our case, since there are only 3 columns of data and we want to use all three, this command is unnecessary.&nbsp; If, however,&nbsp; you want data from a file with many columns but you only need data from column number&nbsp; 0, column number 3, and column number 5, you would write&nbsp;&nbsp;<code>usecols = (0,3,5)</code>.&nbsp;</div><div></div><div><code>angle, V_pd, V_pd_error&nbsp; = np.loadtxt(...)&nbsp;</code>tells Numerical Python to create an array called&nbsp;<code>angle</code> and fill it with values from  the first column of data in the CSV spreadsheet file, then create an array called&nbsp;<code>V_pd</code> and fill it with values from the second column of data, and finally create an array called V_pd_error and fill it with values from the third column of data. The result is three shiny new numpy data arrays we can use in our calculations. </div><div></div><div>What if your data is in a different text file format (such as tab delimited)? You can still use &nbsp;<code>loadtxt</code> to import your data as long as you  modify the&nbsp;<code>delimiter</code>command to match the file format.&nbsp; See the&nbsp;<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html?highlight=loadtxt" target="_blank">numpy.loadtxt</a> manual page for details.&nbsp;</div><div></div><h2 data-label="883907" class="ltx_title_subsection">saving  data to a CSV file</h2><div>&nbsp;</div><div>We now provide an example of how to use  the&nbsp;<code>savetxt</code>  command from Numerical Python (numpy) to save data in csv format. There are admittedly many  other ways to save files in spreadsheet format but this is the simplest method we've found so far using numpy. For more advanced data handling of spreadsheet data files and/or&nbsp; large data sets, you may wish to consider the popular Python Data Analysis Library package called&nbsp;<a href="http://pandas.pydata.org/" target="_blank">pandas</a> or the Hierarchical Data Format (HDF5)&nbsp; Python interface package&nbsp;<a href="http://www.h5py.org/" target="_blank">h5py</a> .&nbsp;</div><div></div><div>Direct numpy import style:&nbsp;</div>