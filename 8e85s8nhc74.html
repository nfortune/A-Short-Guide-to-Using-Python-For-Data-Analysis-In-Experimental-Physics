<div>Notice that our original approach in section&nbsp;<span class="au-ref raw v1">\ref{219511}</span>&nbsp; of explicitly calculating the uncertainty in <span class="math ltx_Math v1">\(V_{pd}\)</span> from Eq. <span class="au-ref raw v1">\ref{eq:delta_V_Malus}</span> and this new approach of using the <code>uncertainties</code> package give equivalent results, but that in both cases we needed a good estimate of&nbsp;<span class="math ltx_Math v1">\(V_0\pm\delta V_0\)</span> to determine&nbsp;<span class="math ltx_Math v1">\(V_{pd}\pm\delta V_{pd}\)</span> at each value of&nbsp;<span class="math ltx_Math v1">\(\theta\)</span>.&nbsp;</div><div></div><div>In general, either of these two approaches will be sufficient for most of our work with data, but notice that because both involve linear expansions of functions about their nominal values, both yield a probably ununcertainty of zero (neglecting&nbsp;<span class="math ltx_Math v1">\(\delta V_1\)</span> for now) at&nbsp;<span class="math ltx_Math v1">\(\phi=\ \theta-\ \theta_0=0\)</span> since&nbsp;<span class="math ltx_Math v1">\(\cos\left(0\pm\delta\phi\right)=\ 0\ +\ 0\ \cdot\delta\phi+\ \frac{1}{2}\cdot\left(\delta\phi\right)^2+\ ...\ =\ 0\)</span> in the linear approximation limit (neglecting terms of order&nbsp;<span class="math ltx_Math v1">\(\left(\delta\phi\right)^2\)</span> and higher).  If you need still more advanced approaches to<a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty" target="_blank"> propagation of uncertainty</a>, the author of &nbsp;<a href="https://pythonhosted.org/uncertainties/" target="_blank">uncertainties</a> recommends looking at&nbsp;&nbsp;<a href="https://pypi.python.org/pypi/soerp">soerp</a>&nbsp;(which extends the calculations to include second-order terms) and&nbsp;<a href="https://pypi.python.org/pypi/mcerp">mcerp</a>&nbsp;(which is a Monte-Carlo approach).&nbsp; According to the uncertainties website, "the&nbsp;<a href="https://pypi.python.org/pypi/soerp">soerp</a> package performs&nbsp;<i>second-order</i> error propagation: this is still quite fast, but the standard deviation of higher-order functions like f(x)&nbsp;=&nbsp;x<sup>3</sup> for x&nbsp;=&nbsp;0Â±0.1 is calculated as being exactly zero (as with&nbsp;<code>uncertainties</code>). The&nbsp;<a href="https://pypi.python.org/pypi/mcerp">mcerp</a> package performs Monte-Carlo calculations, and can in principle yield very precise results, but calculations are much slower than with approximation schemes.</div>