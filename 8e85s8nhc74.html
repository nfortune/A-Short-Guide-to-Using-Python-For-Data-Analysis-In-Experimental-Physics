<div>Notice that our original approach in section&nbsp;<span class="au-ref raw v1">\ref{219511}</span>&nbsp; of explicitly calculating the uncertainty in <span class="math ltx_Math v1">\(V_{pd}\)</span> from Eq. <span class="au-ref raw v1">\ref{eq:delta_V_Malus}</span> and this new approach of using the <code>uncertainties</code> package give equivalent results, but that in both cases we needed a good estimate of&nbsp;<span class="math ltx_Math v1">\(V_0\pm\delta V_0\)</span> to determine&nbsp;<span class="math ltx_Math v1">\(V_{pd}\pm\delta V_{pd}\)</span> at each value of&nbsp;<span class="math ltx_Math v1">\(\theta\)</span>.&nbsp;</div><div></div><div>In general, either of these two approaches will be sufficient for most of our work with data, but notice that because both involve linear expansions of functions about their nominal values, both yield an unrealistically low uncertainty of zero for small variations in&nbsp;<span class="math ltx_Math v1">\(V_0\)</span> and&nbsp;<span class="math ltx_Math v1">\(\phi\)</span> (neglecting&nbsp;<span class="math ltx_Math v1">\(\delta V_1\)</span> for now) at&nbsp;<span class="math ltx_Math v1">\(\phi=\ \theta-\ \theta_0=0\)</span> . This is because an Taylor expansion of&nbsp;<span class="math ltx_Math v1">\(\cos\left(\phi\right)\)</span> around&nbsp;<span class="math ltx_Math v1">\(\phi=0\)</span>&nbsp; yields&nbsp;&nbsp;<span class="math ltx_Math v1">\(\cos\left(0\pm\delta\phi\right)=\ 0\ +\ 0\ \cdot\delta\phi+\ \frac{1}{2}\cdot\left(\delta\phi\right)^2+\ ...\ =\ 0\)</span> in the linear approximation limit (which treats terms of order&nbsp;<span class="math ltx_Math v1">\(\left(\delta\phi\right)^2\)</span> and higher as being negligibly small).  </div><div></div><div>If you need still more advanced approaches to<a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty" target="_blank"> propagation of uncertainty</a>, the author of &nbsp;<a href="https://pythonhosted.org/uncertainties/" target="_blank">uncertainties</a> recommends looking at&nbsp;&nbsp;<a href="https://pypi.python.org/pypi/soerp">soerp</a>&nbsp;and&nbsp;<a href="https://pypi.python.org/pypi/mcerp">mcerp</a>.&nbsp; According to the uncertainties website, "the&nbsp;<a href="https://pypi.python.org/pypi/soerp">soerp</a> package performs&nbsp;<i>second-order</i> error propagation: this is still quite fast, but the standard deviation of higher-order functions like f(x)&nbsp;=&nbsp;x<sup>3</sup> for x&nbsp;=&nbsp;0Â±0.1 is calculated as being exactly zero (as with&nbsp;<code>uncertainties</code>). The&nbsp;<a href="https://pypi.python.org/pypi/mcerp">mcerp</a> package performs Monte-Carlo calculations, and can in principle yield very precise results, but calculations are much slower than with approximation schemes."</div><div></div><h1 data-label="662059" class="ltx_title_section">Installing Python</h1><div></div><div>This section is only relevant if you are planning on running Python on your own computer. If you are running Python within a Jupyter notebook on a webserver or a computer account which has already been configured for your use (such as&nbsp;<a href="https://jove.smith.edu">https://jove.smith.edu</a> for Smith College physics) , this section can be skipped.&nbsp;</div><div></div><h2 data-label="734994" class="ltx_title_subsection">Installing  Python</h2><div>Our focus in this article&nbsp; is on the use of Python to expedite the&nbsp; analysis of your experimental data and not, for example, the specifics of various Python distributions and their relative merits for computational physics in terms of speed, accuracy, and memory requirements.&nbsp; </div><div></div><div>We therefore recommend that if you need to install a Python distribution for scientific data analysis in physics on your own computer, you choose an installer that will automatically install <a href="https://www.python.org/" target="_blank">Python</a>, interactive Python&nbsp; (<a href="https://ipython.org/" target="_blank">iPython</a>) and <a href="https://jupyter.org/" target="_blank">Jupyter</a> notebooks,&nbsp; scientific python development environments (editing, testing, debugging)&nbsp; such as&nbsp;<a href="https://pythonhosted.org/spyder/" target="_blank">Spyder</a> or <a href="https://www.enthought.com/product/canopy/canopy-interactive-debugger" target="_blank">Canopy</a>,&nbsp; and&nbsp; essential&nbsp;<a href="http://www.scipy.org" target="_blank">Scientific Python packages</a> (such as <a href="http://www.numpy.org/" target="_blank">numpy</a>, <a href="https://matplotlib.org/" target="_blank">matplotlib</a> and <a href="https://www.scipy.org/scipylib/index.html" target="_blank">scipy</a>) in a single step, rather than building this from scratch. This provides  ease of installation,  ease of use,&nbsp; and a comprehensive curated set of preinstalled and easily added packages.&nbsp; </div>