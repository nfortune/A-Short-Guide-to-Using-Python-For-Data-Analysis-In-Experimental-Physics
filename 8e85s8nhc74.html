<div>Notice that our original approach in section&nbsp;<span class="au-ref raw v1">\ref{219511}</span>&nbsp; of explicitly calculating the uncertainty in <span class="math ltx_Math v1">\(V_{pd}\)</span> from Eq. <span class="au-ref raw v1">\ref{eq:delta_V_Malus}</span> and this new approach of using the <code>uncertainties</code> package give equivalent results, but that in both cases we needed a good estimate of&nbsp;<span class="math ltx_Math v1">\(V_0\pm\delta V_0\)</span> to determine&nbsp;<span class="math ltx_Math v1">\(V_{pd}\pm\delta V_{pd}\)</span> at each value of&nbsp;<span class="math ltx_Math v1">\(\theta\)</span>.&nbsp;</div><div></div><div>In general, these approaches are sufficient for most work with dataIf you need still more advanced approaches to<a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty" target="_blank"> propagation of uncertainty</a>, the author of &nbsp;<a href="https://pythonhosted.org/uncertainties/" target="_blank">uncertainties</a> recommends looking at&nbsp;&nbsp;<a href="https://pypi.python.org/pypi/soerp">soerp</a>&nbsp;(which extends the calculations to include second-order terms) and&nbsp;<a href="https://pypi.python.org/pypi/mcerp">mcerp</a>&nbsp;(which is a Monte-Carlo approach).&nbsp; According to the uncertainties website, "the&nbsp;<a href="https://pypi.python.org/pypi/soerp">soerp</a> package performs&nbsp;<i>second-order</i> error propagation: this is still quite fast, but the standard deviation of higher-order functions like f(x)&nbsp;=&nbsp;x<sup>3</sup> for x&nbsp;=&nbsp;0Â±0.1 is calculated as being exactly zero (as with&nbsp;<code>uncertainties</code>). The&nbsp;<a href="https://pypi.python.org/pypi/mcerp">mcerp</a> package performs Monte-Carlo calculations, and can in principle yield very precise results, but calculations are much slower than with approximation schemes.</div>