<h2 data-label="606982" class="ltx_title_subsection"> Differentiation</h2><div>One of the most common reasons for data smoothing is to then be able to differentiate the data.&nbsp; When working with evenly spaced data, the savgol_</div><div></div><div>The numerical derivative of the filtered signal&nbsp;<span class="math ltx_Math v1">\(y\left(x\right)\)</span> can then be evaluated at each&nbsp;<span class="math ltx_Math v1">\(x\)</span> value using the&nbsp;<code>numpy</code> function&nbsp;<code>gradient</code>.  For a 1D array of data the gradient will be the same as the derivative&nbsp;<span class="math ltx_Math v1">\(\frac{dy}{dx}\)</span>. According to the &nbsp;<code>numpy.gradient</code> &nbsp;<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.gradient.html#numpy.gradient" target="_blank">reference page</a> , this function "calculates the gradient using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries. " It also has the advantage of not requiring equally spaced data values. </div><div></div><div>Here is a simple example of how to use <code>gradient</code> to numerically calculate&nbsp;<span class="math ltx_Math v1">\(\frac{df}{dx}\)</span> from smoothed&nbsp;<span class="math ltx_Math v1">\(f\left(x_i\right)\)</span> data without knowledge of the function&nbsp;<span class="math ltx_Math v1">\(f\left(x\right)\)</span>, assuming&nbsp; that the data is equally spaced with a sample distance&nbsp;<span class="math ltx_Math v1">\(dx\)</span> of 0.1:&nbsp;</div><div></div><div>In direct numpy import mode, </div>