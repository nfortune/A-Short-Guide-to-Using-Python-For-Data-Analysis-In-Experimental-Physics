<div> The numerical derivative of the filtered signal&nbsp;<span class="math ltx_Math v1">\(y\left(x\right)\)</span> can then be evaluated at each&nbsp;<span class="math ltx_Math v1">\(x\)</span> value using the&nbsp;<code>numpy</code> function&nbsp;<code>gradient</code>.  For a 1D array of data the gradient will be the same as the derivative <span class="math ltx_Math v1">\(\frac{df}{dx}\)</span>. This function "calculates the gradient using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries"and has the&nbsp;advantage of not requiring equally spaced x values.&nbsp; For a 1D array of data this will be the same as the derivative. This function has the advantage of not requiring equally spaced x values.&nbsp; See the&nbsp;<code>numpy.gradient</code>&nbsp;<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.gradient.html#numpy.gradient" target="_blank">reference page</a> for details.&nbsp;</div><div></div><div>For a more detailed guide to numerical differentiation of the filtered signal,  see for example&nbsp;<a href="http://www-personal.umich.edu/~mejn/cp/chapters/int.pdf" target="_blank">Chapter 5: Integrals and Derivatives</a> from the highly recommended Python-based textbook&nbsp;<a href="http://www-personal.umich.edu/~mejn/cp/index.html" target="_blank">Computational Physics</a> by Mark Newman&nbsp;<cite class="ltx_cite raw v1">\cite{mark2013}</cite>.&nbsp;</div>