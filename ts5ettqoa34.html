<div>For details, see the&nbsp;<a href="http://pint.readthedocs.io/en/stable/measurement.html" target="_blank">Pint measurements tutorial</a>.&nbsp; </div><div></div><div>For  general propagation of uncertainty tasks , we use  &nbsp;<a href="https://pythonhosted.org/uncertainties/" target="_blank">Uncertainties</a>: a Python package  written by Eric. O. Lebigot. &nbsp;The uncertainties module returns its result with the uncertainty specified by linear&nbsp;<a href="http://en.wikipedia.org/wiki/Propagation_of_uncertainty">error propagation theory</a>,  correctly taking into account any direct correlations between variables. &nbsp;This is in fact what Pint uses under the hood, so either one should give the same result. &nbsp;</div><h3 data-label="240453" class="ltx_title_subsubsection"></h3><div>If you need still more advanced approaches to<a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty" target="_blank"> propagation of uncertainty</a>, Lebigot recommends trying &nbsp;<a href="https://pypi.python.org/pypi/soerp">soerp</a>&nbsp;(second-order approximations) and&nbsp;<a href="https://pypi.python.org/pypi/mcerp">mcerp</a>&nbsp;(Monte-Carlo approach).&nbsp; I haven't yet done so. </div><div> </div><div>&nbsp;</div><div></div><div>Having done so, the first computational challenge here&nbsp; is that even after experimentally determining &nbsp;<span class="math ltx_Math v1">\(\delta V_0\)</span>,&nbsp;<span class="math ltx_Math v1">\(\delta V_1\)</span>, and&nbsp;<span class="math ltx_Math v1">\(\delta\phi\)</span>, solving for&nbsp;<span class="math ltx_Math v1">\(\delta V\)</span> requires knowledge of&nbsp;<span class="math ltx_Math v1">\(V_0\)</span>. Since the point of curve fitting to the data is to determine&nbsp;<span class="math ltx_Math v1">\(V_0\)</span>, &nbsp; how do we determine the numerical values for &nbsp;<span class="math ltx_Math v1">\(\delta V_{pd}\left(\theta\right)\)</span> needed&nbsp; to find a best estimate of&nbsp;<span class="math ltx_Math v1">\(V_0\)</span>? </div><div></div><div>This is not the impasse that it might seem, however, as we always need to supply an initial guess for our curve-fit parameters and we can make a rough first guess from a graph of the data itself. The solution is to then take the values provided by the curve fit as the initial guesses for a second round of curve fitting, and continue until the result is <b>self-consistent</b> (that is, the output value matches the input value within the reported uncertainty).&nbsp;</div><div></div><div>The second challenge is that the result requires recalculation for every value of&nbsp; &nbsp;<span class="math ltx_Math v1">\(\phi\)</span>, hence the need to have this done by the computer.&nbsp;  In the curve-fit code above, this can be done by writing a Python function for <span class="math ltx_Math v1">\(\delta V_{pd}\)</span> analogous to Eq. <span class="au-ref raw v1">\ref{eq:delta_V_Malus}</span>. </div><div></div>