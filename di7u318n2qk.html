<div>&nbsp;</div><div></div><div> <b>Here  is the procedure for finding self-consistent 'best fit' values for&nbsp;</b><span class="math ltx_Math v1">\(V_0\)</span><b> ,&nbsp;</b><span class="math ltx_Math v1">\(V_1\)</span><b>, and&nbsp;</b><span class="math ltx_Math v1">\(\theta_0\)</span><b> from the curve-fitting routine</b>:&nbsp;</div><div> </div><ol><li>Make  a  rough initial guess for the  parameters&nbsp;<span class="math ltx_Math v1">\(V_0\)</span>,&nbsp;<span class="math ltx_Math v1">\(V_1\)</span>, and&nbsp;<span class="math ltx_Math v1">\(\theta_0\)</span> from a graph of the data.</li><li>Use the values of&nbsp; <span class="math ltx_Math v1">\(V_0\)</span>,&nbsp;<span class="math ltx_Math v1">\(V_1\)</span>, and&nbsp;<span class="math ltx_Math v1">\(\theta_0\)</span> output by the curve-fitting routine as a new 'initial guess'</li><li>Repeat the curve fit&nbsp; (using each  output as a new input) until&nbsp;<span class="math ltx_Math v1">\(V_0\)</span> stops changing.&nbsp; </li></ol><div></div><div></div><h2 data-label="205170" class="ltx_title_subsection">curve fit code</h2><div></div><div>We now turn to the actual Python code for the curve fit. </div><div></div><div>Here we assume the following values have been determined for uncertainties in&nbsp; <span class="math ltx_Math v1">\(V_0\)</span>,&nbsp;<span class="math ltx_Math v1">\(V_1\)</span>, and&nbsp;<span class="math ltx_Math v1">\(\theta\)</span>:</div>